## Lists and Lazy Sequences

Thus far, we've dealt with vectors, hash maps, and hash sets. They cover the majority of use cases. Now we'll address the fourth major data structure in Clojure: the list.

A list, more accurately called a linked list, is somewhat similar to a vector. They both simply hold a sequence of values, but they do so in different ways. Whereas a vector has an internal "table of contents" (called an index) that it uses to look up a value, a linked list simply makes each value point to the next one.

Vectors are faster at looking up values, due to their index, and they can quickly add values to the end. Linked lists are faster at adding values to the beginning, because they simply need to make that value point to whatever was previously first. Another advantage of lists is that they be "lazy".

In programming terms, laziness refers to when something only does work when it needs to. Imagine you had a program that needs to create a collection of the first 10 even numbers and then square each of them. Imperatively, you'd have to do this work upfront, whether you end up needing all 10 numbers of not.

In Clojure, the aforementioned problem could be solved with laziness. First, let's create a list that pretends to contain *all* numbers. We can do this with `(range)`, which returns a lazy sequence representing every number starting at zero. In Nightcode's lower-left REPL, try typing the following lines:

```clojure
(def all-numbers (range))
```

Be careful -- if you actually type `all-numbers` into the REPL to see its value, the REPL will lock up, because it will try to compute the entire list, which is infinite!

Now we can use it to create a new infinite sequence by running it through `filter` to get a list of all even numbers:

```clojure
(def all-evens (filter even? all-numbers))
```

If you want to see the first 10 numbers in this list, we can use `take` like this:

```clojure
(take 10 all-evens)
; (0 2 4 6 8 10 12 14 16 18)
```

The way this works is, lazy sequences don't actually compute their contents until a function forces them to. The `take` function does this, but it only asks for the first 10, so the lazy sequence doesn't bother going further.

Now let's write a quick function that squares a number, and then `map` it over `all-evens`:

```clojure
(defn square [n] (* n n)) ; defines a function
(def all-squared-evens (map square all-evens))
```

Now run `take` on it:

```clojure
(take 10 all-squared-evens)
; (0 4 16 36 64 100 144 196 256 324)
```

There we go! We now have a list of the first ten even numbers after squaring them.

Why is this useful? One reason is that we can "simulate" a computation, but only do the work when we need to. At some point down the line, our program may decide it only needs the first five numbers, and by using lazy sequences we can avoid unnecessary computations by delaying them until we absolutely need to do them.

## CardsJava

Create a new Java project. We're going to try to calculate all possible four-card hands (we'll avoid five-card hands to make it compute faster). To kick things off, we will, as always, start with our data. To represent a card in Java, let's create a class that uses enums for the suit and the rank:

```java
public class Card {
    enum Suit {
        CLUBS,
        DIAMONDS,
        HEARTS,
        SPADES
    }

    enum Rank {
        ACE,
        TWO,
        THREE,
        FOUR,
        FIVE,
        SIX,
        SEVEN,
        EIGHT,
        NINE,
        TEN,
        JACK,
        QUEEN,
        KING
    }

    Suit suit;
    Rank rank;
    
    public Card(Suit suit, Rank rank) {
        this.suit = suit;
        this.rank = rank;
    }
}
```

Now, in the main class, create a method that returns a deck of cards by iterating over both enums. We'll store them in a `HashSet` to make sure the deck has only unique cards:

```java
public class Main {
    static HashSet<Card> createDeck() {
        HashSet<Card> deck = new HashSet();
        for (Card.Suit suit : Card.Suit.values()) {
            for (Card.Rank rank : Card.Rank.values()) {
                Card c = new Card(suit, rank);
                deck.add(c);
            }
        }
        return deck;
    }
    
    public static void main(String[] args) {
        
    }
}
```

Before we go on, let's try it out. In the main method, create a deck and try to add another card to it.

```java
public class Main {
    ...
    
    public static void main(String[] args) {
        HashSet<Card> deck = createDeck();
        deck.add(new Card(Card.Suit.SPADES, Card.Rank.ACE));
        System.out.println(deck.size());
    }
}
```

We have a problem! Somehow, the `HashSet` allowed us to add an ace of spades, even though it already has one. This is because we haven't taught Java how to determine equality of cards. To do so, go back to the cards class and right click inside the file to access IntelliJ's "Generate..." feature. Choose the "equals and hashCode" option. IntelliJ will generate them for you like this:

```java
public class Card {
    ...
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Card card = (Card) o;

        if (suit != card.suit) return false;
        return rank == card.rank;

    }

    @Override
    public int hashCode() {
        int result = suit.hashCode();
        result = 31 * result + rank.hashCode();
        return result;
    }
}
```

Now when you re-run the main method, the deck should have 52 cards. Now let's attempt to write the method that generates all possible hands. This will end up giving us a `HashSet<HashSet<Card>>`, because we want to make sure we don't have any duplicate hands as well. We can do this by creating several layers of `for` loops:

```java
public class Main {
    ...
    
    static HashSet<HashSet<Card>> createHands(HashSet<Card> deck) {
        HashSet<HashSet<Card>> hands = new HashSet();
        for (Card c1 : deck) {
            HashSet<Card> deck2 = (HashSet<Card>) deck.clone();
            deck2.remove(c1);
            for (Card c2 : deck2) {
                HashSet<Card> deck3 = (HashSet<Card>) deck2.clone();
                deck3.remove(c2);
                for (Card c3 : deck3) {
                    HashSet<Card> deck4 = (HashSet<Card>) deck3.clone();
                    deck4.remove(c3);
                    for (Card c4 : deck4) {
                        HashSet<Card> hand = new HashSet();
                        hand.add(c1);
                        hand.add(c2);
                        hand.add(c3);
                        hand.add(c4);
                        hands.add(hand);
                    }
                }
            }
        }
        return hands;
    }
    
    public static void main(String[] args) {
        HashSet<Card> deck = createDeck();
        HashSet<HashSet<Card>> hands = createHands(deck);
        System.out.println(hands.size());
    }
}
```

The changes to the main method should now make it print out the number of all possible four-card hands. According to [this resource](http://people.math.sfu.ca/~alspach/comp17/), the answer should be 270,725.

Now let's try to filter out only the decks which are flushes. We can just make a method that checks a single deck. Then we can use a stream to filter the results with that method:

```java
public class Main {
    ...
    
    static boolean isFlush(HashSet<Card> hand) {
        HashSet<Card.Suit> suits = hand.stream()
                .map(card -> {
                    return card.suit;
                })
                .collect(Collectors.toCollection(HashSet::new));
        return suits.size() == 1;
    }
    
    public static void main(String[] args) {
        HashSet<Card> deck = createDeck();
        HashSet<HashSet<Card>> hands = createHands(deck);
        hands = hands.stream()
                .filter(Main::isFlush)
                .collect(Collectors.toCollection(HashSet::new));
        System.out.println(hands.size());
    }
}
```

## cards-clojure

Create a new console project. In Clojure, it's normal to represent most things with plain data structures. In the case of, for example, a 10 of hearts, we could represent it as a hash map: `{:rank 10, :suit :hearts}`.
