## people-clojure

In Nightcode, click "New Project", and after choosing whatever directory you'd like to store your projects in, write `people-clojure` in the text field. In the next dialog, simply leave "Console" selected and click "Create Project".

Begin by downloading [people.csv](https://raw.githubusercontent.com/oakes/clojure-assignments/master/curriculum/assets/people.csv) into the root of the project. Our goal will be to read this file, parse it into lines, and allow the user to display only the people from a particular country.

In the project tree on the left, drill down into the `src` folder and select `core.clj`. Right now, it should look like this:

```clojure
(ns people-clojure.core
  (:gen-class))

(defn -main []
  (println "Hello, World!"))
```

The `-main` function is equivalent to the main method in Java. In this case, it takes zero arguments (hence the empty `[]`) and prints something. What we want to do is build a simple program that lets you type lines of text, saves them somewhere, and prints them all out when you are finished.

First, try clicking the "Run" button in the bottom right pane. After some time, you should see it print the text out. Running a program this way is normal for most languages, but in Clojure, we typically develop interactively by running a REPL. It provides a much faster feedback loop.

The REPL on the bottom left is standalone, but we need a special REPL that runs inside our project. To get it, click "Run with REPL" in the bottom right pane. Eventually you'll see a prompt appear in the pane. Now try running `(-main)` and you'll see it print again.

Now change the string in your code (for example, add an exclaimation point). After saving, hit the "Reload" button, which will reload the REPL with the latest changes. Now try running `(-main)` again in the REPL and confirm that the changed string is now printing. This is a much faster way to make and try changes than constantly re-running the project.

First let's try reading the file into a string. This can be done simply with the `slurp` function. Modify the main function to read people.csv:

```clojure
...

(defn -main []
  (slurp "people.csv"))
```

Now save and reload the file. In the REPL, run `(-main)`, and you'll see a large string print out:

```clojure
"id,first_name,last_name,email,country,ip_address\n1,Martha,Jenkins,mjenkins0@un.org,France,97.252.235.143\n2,Kathleen,Medina,kmedina1@unc.edu,Czech Republic,149.62.63.167\n3,Earl,Murray,emurray2@va.gov,Poland,242.239.132.230\n4,Teresa,Fox,tfox3@webnode.com,Russia,136.0.65.186..."
```

We now need to save this string in a variable. In the past, we used `def` to do this, but that is for gloabl variables. To make a local variable, use let like this:

```clojure
(defn -main []
  (let [people (slurp "people.csv")]
    people))
```

What's happening here is that the string is being saved in a local variable called `people`, and then it immediately returns it. In clojure, you return a value by simply putting it at the end of a function.

Next, we need to split this string into lines. To do this, we need to bring in a special namespace that is not included by default. To do so, add `(:require [clojure.string :as str])` to our `ns` declaration. This is similar to importing a package in Java. For brevity, we are attaching an alias called `str` so we don't have to type the full name every time we use a function from it.

```clojure
(ns people-clojure.core
  (:require [clojure.string :as str])
  (:gen-class))

...
```

Now go back to the main function. We are going to use a function called `split-lines` from that namespace. Just as in the past, we are going to change the variable by redefining it. In a `let`, we can do this by making a new pair inside the "binding vector" where our original local variable was defined:

```clojure
(defn -main []
  (let [people (slurp "people.csv")
        people (str/split-lines people)]
    people))
```

If you save, reload, and run `(-main)` in the REPL again, you'll see it output all the lines as separate strings contained within a vector:

```clojure
["id,first_name,last_name,email,country,ip_address"
 "1,Martha,Jenkins,mjenkins0@un.org,France,97.252.235.143"
 "2,Kathleen,Medina,kmedina1@unc.edu,Czech Republic,149.62.63.167" "3,Earl,Murray,emurray2@va.gov,Poland,242.239.132.230"
 "4,Teresa,Fox,tfox3@webnode.com,Russia,136.0.65.186" "5,Carolyn,West,cwest4@admin.ch,Nigeria,240.149.227.109"
 "6,Marie,Lawson,mlawson5@youtube.com,China,238.101.184.197" "7,Eugene,Stone,estone6@nature.com,Colombia,55.107.194.185"
 "8,Nicholas,Oliver,noliver7@slate.com,China,159.45.204.128" "9,Carol,Flores,cflores8@reddit.com,Russia,62.117.22.131"
 ...]
```

We're getting somewhere! Now we need to go over each line and split them by commas. This will make the lines be vectors containing a separate string for each column. To do this, we need to use `map` to run a function over the lines that uses the `split` function on each of them:

```clojure
(defn -main []
  (let [people (slurp "people.csv")
        people (str/split-lines people)
        people (map (fn [line]
                      (str/split line #","))
                 people)]
    people))
```

Save, reload, and run `(-main)` in the REPL again:

```clojure
(["id" "first_name" "last_name" "email" "country" "ip_address"]
 ["1" "Martha" "Jenkins" "mjenkins0@un.org" "France" "97.252.235.143"]
 ["2" "Kathleen" "Medina" "kmedina1@unc.edu" "Czech Republic" "149.62.63.167"]
 ["3" "Earl" "Murray" "emurray2@va.gov" "Poland" "242.239.132.230"]
 ["4" "Teresa" "Fox" "tfox3@webnode.com" "Russia" "136.0.65.186"]
 ...)
```

We now have each column of each line in a separate string. We should now separate the header from the rest of the lines, since it is special. We can do that by creating a new local variable called `header` that takes the first item from `people`, and then redefine `people` to contain everything after the first value:

```clojure
(defn -main []
  (let [people (slurp "people.csv")
        people (str/split-lines people)
        people (map (fn [line]
                      (str/split line #","))
                 people)
        header (first people)
        people (rest people)]
    people))
```

Our next task is to turn each line in `people` into a clojure hash map, using the strings in `header` as the keys. We can get started by first simple interleaving the header's strings into every line, so the first line will be something like `["id" "1" "first_name" "Martha" "last_name" "Jenkins" "email" "mjenkins0@un.org" ...]`. We can do that like this:

```clojure
(defn -main []
  (let [people (slurp "people.csv")
        people (str/split-lines people)
        people (map (fn [line]
                      (str/split line #","))
                 people)
        header (first people)
        people (rest people)
        people (map (fn [line]
                      (interleave header line))
                 people)]
    people))
```

Save, reload, and run `(-main)` in the REPL again:

```clojure
(("id" "1" "first_name" "Martha" "last_name" "Jenkins" "email" "mjenkins0@un.org" "country" "France" "ip_address" "97.252.235.143")
 ("id" "2" "first_name" "Kathleen" "last_name" "Medina" "email" "kmedina1@unc.edu" "country" "Czech Republic" "ip_address" "149.62.63.167")
 ("id" "3" "first_name" "Earl" "last_name" "Murray" "email" "emurray2@va.gov" "country" "Poland" "ip_address" "242.239.132.230")
 ("id" "4" "first_name" "Teresa" "last_name" "Fox" "email" "tfox3@webnode.com" "country" "Russia" "ip_address" "136.0.65.186")
 ...)
```

To turn a collection of values into a hash map, you simply run `(apply hash-map ...)`. For example, try running `(apply hash-map ["first_name" "Martha" "last_name" "Jenkins"])` in your REPL. You'll get back `{"last_name" "Jenkins", "first_name" "Martha"}` (remember, the order of the key-value pairs is effectively random, just like in Java's `HashMap`).

So, in our case, we need to run that function on every line. We can do that by modifying the latest `map` function like this:

```clojure
(defn -main []
  (let [people (slurp "people.csv")
        people (str/split-lines people)
        people (map (fn [line]
                      (str/split line #","))
                 people)
        header (first people)
        people (rest people)
        people (map (fn [line]
                      (apply hash-map (interleave header line)))
                 people)]
    people))
```

Save, reload, and run `(-main)` in the REPL again:

```clojure
({"country" "France", "id" "1", "email" "mjenkins0@un.org", "last_name" "Jenkins", "first_name" "Martha", "ip_address" "97.252.235.143"}
 {"country" "Czech Republic", "id" "2", "email" "kmedina1@unc.edu", "last_name" "Medina", "first_name" "Kathleen", "ip_address" "149.62.63.167"}
 {"country" "Poland", "id" "3", "email" "emurray2@va.gov", "last_name" "Murray", "first_name" "Earl", "ip_address" "242.239.132.230"}
 {"country" "Russia", "id" "4", "email" "tfox3@webnode.com", "last_name" "Fox", "first_name" "Teresa", "ip_address" "136.0.65.186"}
 ...)
```
